\documentclass[10pt,a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[polish]{babel}
\usepackage{hyperref}
\usepackage[paper=a4paper,margin=1in]{geometry}
\usepackage{tabularx} 
\usepackage{helvet}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{algpseudocode}
\usepackage{tikz}
\usepackage{tkz-graph}
\usepackage{listings,xcolor}
\usepackage{scrextend}
\usepackage{float}
\usepackage{subcaption}
\renewcommand{\familydefault}{\sfdefault}
\setlength{\parindent}{0pt}
\newtheorem{definition}{Definicja}
\newtheorem{theorem}{Twierdzenie}
\newtheorem{lemma}{Lemat}
\newtheorem{invariant}{Niezmiennik}
\newtheorem{conculsion}{Wniosek}

\begin{document}
	\begin{titlepage}
		\newgeometry{top=1in,bottom=1in,right=1.5in,left=1.5in}
		\begin{center}
			{\fontsize{14}{12}\selectfont Politechnika Warszawska \\ Wydział Matematyki i Nauk Informacyjnych}
			
		\end{center}
		
		\vspace{1cm}
		\begin{center}
			\includegraphics[width=0.3\textwidth]{images/logo.png}
		\end{center}
		\vspace{3cm}
		
		\begin{center}
			\textbf{{\fontsize{26}{12}\selectfont Chromatyczna Teoria Grafów}}
			
			\vspace{2cm}
			\textbf{{\fontsize{22}{12}\selectfont Dokumentacja projektowa wstępna}}
			\vspace{1cm}
			
			\textbf{{\fontsize{13.5}{12}\selectfont Chimedshirchin Batjargal, Mateusz Rymuszka}}
			
			\vspace{6cm}
			\textbf{{\fontsize{13.5}{12}\selectfont \today}}
		\end{center}  
	\end{titlepage}
	
	{\fontsize{13.5}{12}\selectfont
		\tableofcontents
		\vspace{1cm}
		{\renewcommand{\arraystretch}{2.0}
		
	}}
	
	
	\section{Abstrakt}
	
	Przedmiotem projektu realizowanego w ramach przedmiotu Chromatyczna Teoria Grafów przez autorów tego dokumentu jest analiza problemu kolorowania warstwowego grafu. Zespół przygotuje, zaimplementuje oraz przetestuje działanie trzech algorytmy, które będą starały się pokolorować grafy wielowarstwowe w lepszy sposób niż naiwny algorytm duplikacji koloru na wiele warstw. W dokumentacji przedstawi teoretyczny opis problemu wraz z proponowanymi algorytmami, a następnie opisze sposób działania programu i przedstawi raport z testów na wybranych rodzajach grafów, podsumowując to wszystko wnioskami płynącymi z obserwacji.
	
	\section{Opis teoretyczny problemu}
	
	\begin{definition}\label{def:1}
		\textbf{Kolorowaniem $p$-warstwowym} grafu $G$ nazywamy takie przyporządkowanie $c: v \rightarrow 2^{C}$, gdzie każdemu wierzchołkowi $v \in V(G)$ przypisujemy podzbiór $C'$ zbioru kolorów $C$ taki, że $|C'| = p$.
	\end{definition}

	\begin{definition}\label{def:2}
		Kolorowanie $p$-warstwowe grafu $G$ nazywamy \textbf{właściwym (poprawnym, optymalnym)}, jeżeli dla dowolnego $v \in V(G)$ przecięcia zbioru kolorów tego wierzchołka i kolorów każdego jego sąsiada są zbiorami pustymi, tzn.
		\[ \forall u, v \in V(G) \quad \left\{u, v\right\} \in E(G) \implies c(u) \cap c(v) = \emptyset \]
	\end{definition}

	Ogólnie rzecz ujmując, kolorowanie wielowarstwowe grafu jest rozszerzeniem zwykłego kolorowania grafu na wiele wymiarów. Kolorowanie jednowarstwowe jest tożsame z klasyczną definicją kolorowania wierzchołkowego grafu.
	
	\begin{definition}
		\textbf{$p$-warstwową liczbą chromatyczną} grafu $G$ nazywamy najmniejsze $q$ takie, że istnieje poprawne $p$-warstwowe pokolorowanie grafu $G$ używające $q$ kolorów.\\
		\textbf{Chromatycznym współczynnikiem $p$-warstwowym} grafu $G$ nazywamy stosunek $p$-warstwowej liczby chromatycznej do liczby warstw.
	\end{definition}

	Okazuje się, że $\chi_{p}G \leq p \chi G$. Gdy weźmiemy bowiem dobre $\chi G$-pokolorowanie $c: V \rightarrow C$ grafu $G$ i dla każdego $v \in V$ przypiszemy mu $c'(v) = \left\{r \cdot |C| + c(v): r \in \left\{1,...,p\right\}\right\}$, to uzyskamy $p \chi G$-pokolorowanie $p$-warstwowe. Nazwijmy je pokolorowaniem $p$-warstwowym grafu $G$ \textbf{równoległym do klasycznego}.
	\\~\\
	Przykładem grafu, który dla którego zachodzi ostra nierówność, jest nieparzysty cykl o wielkości przekraczającej trzy wierzchołki. Takie kolorowanie będziemy nazywać \textbf{lepszym od klasycznego}.
	
	\begin{figure}[H]
		\centering
		\begin{tikzpicture}
			\node[circle, draw, fill=none] (1) [label=south west:{1,2}] at (0,0) {};
			\node[circle, draw, fill=none] (2) [label=south east:{3,4}] at (4,0) {};
			\node[circle, draw, fill=none] (3) [label=south east:{5,1}] at (5,4) {};
			\node[circle, draw, fill=none] (4) [label=north:{2,3}] at (2,6) {};
			\node[circle, draw, fill=none] (5) [label=south west:{4,5}] at (-1,4) {};
			\draw (1) -- (2) -- (3) -- (4) -- (5) -- (1);
		\end{tikzpicture}
		\caption{Przykład 2,5-pokolorowania 2-warstwowego dla grafu $C_{5}$}
	\end{figure}
	
	Problem polega na znalezieniu takiego $p$-warstwowego pokolorowania dla zadanego $p$, aby dla pewnych grafów (takich, gdzie jest to możliwe) $\chi_{p}G < p \chi G$.
	
	\section{Proponowane algorytmy}
	
	Ponieważ problem znalezienia $p$-warstwowego grafu jest NP-trudny (można to wykazać, rozwijając graf warstwowo, gdzie każdy wierzchołek tworzy $p$-krotną klikę, zachowując połączenia z wierzchołkami w każdej z warstw), nie możemy znaleźć takiego pokolorowania w czasie wielomianowym. Zespół skupi się na poszukiwaniu algorytmu aproksymacyjnego, który przy zastosowaniu odpowiedniego podejścia do problemu, a być może pewnych heurystyk, będzie w stanie osiągać rezultat dla niektórych grafów.
	\\~\\
	Wspólnym mianownikiem tych algorytmów powinna być troska, aby starać się kolorować "chaotycznie", tzn. nie powtarzać tych samych zbiorów kolorów w wierzchołkach niezależnych. Taki układ może nas potem zmusić do użycia większej liczby kolorów, a w efekcie uzyskamy pokolorowanie na $p \cdot \chi G$ kolorów.
	
	\subsection{Zmodyfikowany algorytm AMIS}
	
	Algorytm AMIS (\textit{ang. approximately maximum independent set}) jest jednym z efektywniejszych algorytmów wielomianowych kolorowania grafu. W klasycznym problemie, polega on na wyborze spośród niepokolorowanych wierzchołków zbioru niezależnego i pokolorowanie go na nowy kolor. \\~\\
	Algorytm można byłoby zaaplikować bez większych zmian (dopóty wierzchołek uznajemy za niepokolorowany, dopóki nie posiada zbioru $p$ kolorów przypisanych do niego). Istnieje jednak ryzyko, że wybierając te same zbiory niezależne w kolejnych iteracjach algorytmu znajdowania zachłannego zbiorów niezależnych, uzyskalibyśmy pokolorowanie równoległe do klasycznego. Zależy nam zatem, aby w kolejnych iteracjach zbiory niezależne jednocześnie  nie były tożsame oraz nie były rozłączne. \\~\\
	Zaproponowany algorytm będzie korzystał ze zoptymalizowanej wersji algorytmu GIS (\textit{ang. greedy independent sets}), w którym zamiast wyboru jednego wierzchołka, będziemy wybierać dla każdego wierzchołka, czy powinien się on znaleźć w nowym zbiorze wierzchołków niezależnych. Będziemy również pamiętać dla każdego wierzchołka, ile razy znalazł się on już w zbiorze niezależnym. Po wyborze wierzchołków do naszego zbioru niezależnego, będziemy analizować wszystkie krawędzie między kandydatami i wyrzucać jeden z wierzchołków. Będzie to wierzchołek, który znalazł się więcej lub mniej razy w zbiorze niezależnym (wyboru dokonujemy na zmianę).
	
	\subsubsection{Pseudokod}
	
	\begin{algorithmic}
		\State \textbf{Wejście:} graf $G$ i tablica wystąpień w zbiorach niezależnych wierzchołków $f$
		\\
		\Function {GreedyIndependentSet}{$G$, $f$}
			\State $I \coloneqq \varnothing$
			\State old $\coloneqq true$
			\\
			\ForAll{$v \in V(G)$}
				\If{$unif(0, 1) \leq \deg_{G}^{-1} v$}
					\State $I \coloneqq I \cup \left\{v\right\}$
				\EndIf
			\EndFor
			\ForAll{$\left\{u, v\right\} \in E(G)$}
				\If{$u,v \in I$}
					\If{$f(u) \leq f(v) \, \iff $ old}
						\State $I \coloneqq I - \left\{u\right\}$
					\Else
						\State $I \coloneqq I - \left\{v\right\}$
					\EndIf
					\State old $\coloneqq \neg$ old
				\EndIf
			\EndFor
			\State \Return $I \, \cup \, $ \Call {GreedyIndependentSet}{$G[V(G) - I]$, $f$}
		\EndFunction
	\end{algorithmic}
	
	\begin{algorithmic}
		\State \textbf{Wejście:} graf $G$
		\\
		\Function {Color}{$G$}
			\State colored $\coloneqq 0$
			\State color $\coloneqq 1$
			\State $c \coloneqq \left[\right]$
			\State $f \coloneqq \left[\right]$
			\\
			\ForAll{$v \in V(G)$}
				\State $c(v) \coloneqq \varnothing$
				\State $f(v) \coloneqq 0$
			\EndFor
			\While{colored $< p \cdot |V(G)|$}
				\State $I \coloneqq $ \Call {GreedyIndependentSet}{$G\left[\left\{v \in V(G) : |c(v)| < p \right\}\right]$, $f$}
				\ForAll{$v \in I$}
					\State $c(v) \coloneqq c(v) \cup \left\{ \text{color} \right\}$
					\State $f(v) \coloneqq f(v) + 1$
					\State colored $\coloneqq$ colored $ + 1$
				\EndFor
			\EndWhile
			\State \Return $(c, \text{color})$
		\EndFunction
	\end{algorithmic}

	\subsection{Zmodyfikowany algorytm DSATUR}
	
	Algorytm DSATUR należy do rodziny algorytmów sekwencyjnych. W klasycznym problemie, polega on na wyborze spośród niepokolorowanych wierzchołków zbioru niezależnego i pokolorowanie go na nowy kolor. Zespół postanowił nieco zmodyfikować ten algorytm i zbadać jego działanie dla problemu kolorowania wielowarstwowego.
	\\~\\
	Saturację w klasycznej wersji tego algorytmu traktowaliśmy jako liczbę unikalnych kolorów w sąsiednich pokolorowanych wierzchołkach. Aby algorytm działał dla wielu warstw, jednocześnie uwzględniając kolory znajdujące się u sąsiadów oraz w wierzchołku, należy zdefiniować nowy porządek. 
	\\~\\
	W celu analizy problemu, możemy rozpatrywać saturację wielorako; zdefiniujmy:
	\begin{itemize}
		\item saturację zewnętrzną, będącą ilością unikalnych kolorów użytych do pokolorowania wierzchołków sąsiednich, tzn.
		\[S^{OUT}_{G}(v) = \left|\bigcup_{u \in N_{G}(v)} c(u)\right|\]
		\item saturację wewnętrzną, będącą ilością kolorów użytych do pokolorowania wierzchołka, tzn.
		\[S^{IN}_{G}(v) = |c(v)|\]
		\item saturację całkowitą, będącą ilością unikalnych kolorów użytych do pokolorowania wierzchołków sąsiednich, tzn.
		\[S_{G}(v) = \left|\left(\bigcup_{u \in N_{G}(v)} c(u) \right) \cup c(v)\right|\]
	\end{itemize}
	Ponieważ $\forall u,v \in V(G) \quad {u, v} \in E(G) \implies c(u) \cap c(v) = \emptyset$ dla poprawnego $p$-warstwowego pokolorowania $c$ grafu $G$, mamy $S_{G}(v) = S^{OUT}_{G}(v) + S^{IN}_{G}(v)$. 
	\\~\\
	W każdym przypadku saturacją będzie saturacja całkowita i po niej będziemy w pierwszej kolejności sortować. W razie remisów wybieramy wierzchołek o większej saturacji wewnętrznej, gdyż później, gdy jego sąsiedzi mogą dostać kolejne kolory i będzie go ciężej pokolorować.

	\subsubsection{Pseudokod}

	\begin{algorithmic}
		\State \textbf{Wejście:} graf $G$
		\\
		\State colored $\coloneqq 0$
		\State max\_color $\coloneqq 0$ 
		\\
		\Function {Color}{$G$}
			\State $c \coloneqq \left[\right]$
			\State $s \coloneqq \left[\right]$
			\\
			\ForAll{$v \in V(G)$}
				\State $c(v) = \varnothing$
				\State $s(v) = \varnothing$
			\EndFor
			\\
			\State $v \coloneqq rand(\left\{v \in V(G): \forall u \in V(G) \deg_{G} v \geq \deg_{G} u \right\})$
			\State \Call {ColorVertex}{$v$, \&$c$, \&$s$}
			\\
			\While{colored $< p \cdot |V(G)|$}
				\State $v \coloneqq rand(\left\{v \in V(G): \forall u \in V(G) S_{G} v \geq S_{G} u \right\})$
				\State \Call {ColorVertex}{$v$, \&$c$, \&$s$}
			\EndWhile
			\\
			\State \Return $(c, \text{max\_color})$
		\EndFunction
		\pagebreak
		\Procedure {ColorVertex}{$v$, \&$c$, \&$s$}
			\State color $\coloneqq 1$
			\While{color $\in s(v)$}
				\State color $\coloneqq$ color $+ 1$
			\EndWhile
			\State $c(v) = c(v) \cup \left\{\text{color}\right\}$
			\State colored $\coloneqq$ colored $ + 1$
			\\
			\If{color $>$ max\_color}
				\State max\_color $\coloneqq$ color
			\EndIf
			\\
			\State $s(v) = s(v) \cup \left\{\text{color}\right\}$
			\ForAll{$u \in N_{G}(v)$}
				\State $s(v) = s(v) \cup \left\{\text{color}\right\}$
			\EndFor
		\EndProcedure
	\end{algorithmic}

	\subsection{Zmodyfikowany algorytm CS}
	
	Ostatnim algorytmem zaproponowanym przez zespół będzie zmodyfikowany algorytm podobny do algorytmu CS (\textit{ang. connected sequential}). Jego modyfikacja będzie polegała na tym, że w przypadku konieczności użycia koloru, zostanie uruchomiona procedura wymiany, bazująca na algorytmie wyznaczania permutacji Fishera-Yatesa.
	\\~\\
	Algorytm zakłada, że w przypadku braku dostępnego koloru z puli, będziemy po kolei iść wzdłuż pewnej ścieżki od naszego wierzchołka i próbować wymieniać kolory do momentu, gdy któryś z wierzchołków będzie się dało pokolorować użytymi już kolorami, albo gdy algorytm zakończy permutację. Nowego koloru użyjemy tylko w drugim przypadku. Aby zwiększyć skuteczność, będziemy sprawdzać wymianę wszystkich możliwych kolorów.
	
	\subsubsection{Pseudokod}
	
	\begin{algorithmic}
		\State \textbf{Wejście:} graf $G$ \\
		\State colored $\coloneqq 0$
		\State max\_color $\coloneqq 0$
		\\
		\Function {Color}{$G$}
			\State $c \coloneqq \left[\right]$
			\ForAll{$v \in V(G)$}
				\State $c(v) = \varnothing$
			\EndFor
			\\
			\ForAll{$v \in V(G)$, $l \in \left\{1,...,p\right\}$}
				\ForAll{color $\in \left\{1,...,\text{max\_color}\right\}$}
					\If{color $\notin c\left[\left\{v\right\} \cup N_{G}(v) \right]$}
						\State $c(v) \coloneqq c(v) \cup \left\{\text{color}\right\}$
						\State \textbf{break}
					\EndIf
				\EndFor
				\If{$\neg$\Call {ColorInterchange}{$v$, \&$G$, \&$c$}}
					\State $c(v) \coloneqq c(v) \cup \left\{\text{color} + 1\right\}$
					\State max\_color $\coloneqq$ max\_color $+ 1$
				\EndIf
			\EndFor
			\State \Return $(c, \text{max\_color})$
		\EndFunction
		\\
		\Procedure {ColorInterchange}{$v$, \&$G$, \&$c$}
			\ForAll{$i \in {1,...,ANNEALING\_CONSTANT}$}
				\State $u \coloneqq rand(N_{G}(v))$
				\State $X = c(u) \cap c[N_{G}(v) - \left\{u\right\}]$
				\ForAll{$x \in X$}
					\ForAll{color $\in \left\{1,...,\text{max\_color}\right\}$}
						\If{color $\notin c\left[\left\{u\right\} \cup N_{G}(u) \right]$}
							\State $c(v) \coloneqq c(v) \cup \left\{x\right\}$
							\State $c(u) \coloneqq c(u) - \left\{x\right\} \cup \left\{\text{color}\right\}$
							\State \Return $true$
						\EndIf
					\EndFor
				\EndFor
				\State $v \coloneqq u$
			\EndFor
			\State \Return $false$
		\EndProcedure
	\end{algorithmic}	
	
	\section{Założenia techniczne}
	
	W wyborze języka, w którym zostanie stworzony program, zespół kierował się przejrzystością implementacji, aby móc skupić się na teoretycznej części problemu. Ostatecznie, program zostanie napisany w języku C\# - duży wpływ miał tutaj fakt, że był to jeden z niewielu języków, który jest dobrze znany obu członkom zespołu. Jest to język stosujący paradygmat programowania obiektowego, co pozwoli nam potraktować grafy w bardziej obrazowy sposób podczas implementacji. Dodatkowo, posiada duże wsparcie społeczności oraz bindingi do bibliotek wizualizujących grafy (m.in. Graphviz). Zaletą jest również większa prędkość obliczeń na maszynie wirtualnej .NET w stosunku do języków interpretowanych.
	\\~\\
	Projekt będzie obejmował:
	\begin{itemize}
		\item interfejs użytkownika (parser wejścia, komunikaty itp.)
		\item implementację wyżej wymienionych algorytmów 
		\item prezentację wyniku (wyjście tekstowe + wizualizacja za pomocą biblioteki graphviz)
		\item przykładowe benchmarki testujące skuteczność oraz czas wykonania na wybranych grafach
	\end{itemize}

	\vfill
	
	\begin{thebibliography}{0}
		\bibitem{kubale-article}
		Marek Kubale, \textit{Analiza efektywności algorytmów kolorowania grafów}, PTM 1980\\
		\url{https://wydawnictwa.ptm.org.pl/index.php/matematyka-stosowana/article/viewFile/1531/1457}\\
		\textit{(dostęp: \today)}
		
		\bibitem{kubale-book}
		Marek Kubale, \textit{Optymalizacja dyskretna. Modele i metody kolorownia grafów}, WNT 2002
		
		\bibitem{radin-thesis}
		Andrew Radin, \textit{Graph coloring heuristics from investigation ofsmallest hard to color graphs}, RIT Scholar Works 2000
		\url{http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.867.178\&rep=rep1\&type=pdf}
		\textit{(dostęp: \today)}
		
		
	\end{thebibliography}
	

\end{document}