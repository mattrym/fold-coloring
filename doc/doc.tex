\documentclass[10pt,a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[polish]{babel}
\usepackage{hyperref}
\usepackage[paper=a4paper,margin=1in]{geometry}
\usepackage{tabularx} 
\usepackage{helvet}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{algpseudocode}
\usepackage{tikz}
\usepackage{tkz-graph}
\usepackage{listings,xcolor}
\usepackage{scrextend}
\usepackage{float}
\usepackage{subcaption}
\renewcommand{\familydefault}{\sfdefault}
\setlength{\parindent}{0pt}
\newtheorem{definition}{Definicja}
\newtheorem{theorem}{Twierdzenie}
\newtheorem{lemma}{Lemat}
\newtheorem{invariant}{Niezmiennik}
\newtheorem{conculsion}{Wniosek}

\begin{document}
	\begin{titlepage}
		\newgeometry{top=1in,bottom=1in,right=1.5in,left=1.5in}
		\begin{center}
			{\fontsize{14}{12}\selectfont Politechnika Warszawska \\ Wydział Matematyki i Nauk Informacyjnych}
			
		\end{center}
		
		\vspace{1cm}
		\begin{center}
			\includegraphics[width=0.3\textwidth]{images/logo.png}
		\end{center}
		\vspace{3cm}
		
		\begin{center}
			\textbf{{\fontsize{26}{12}\selectfont Chromatyczna Teoria Grafów}}
			
			\vspace{2cm}
			\textbf{{\fontsize{22}{12}\selectfont Dokumentacja projektowa}}
			\vspace{1cm}
			
			\textbf{{\fontsize{13.5}{12}\selectfont Chimedshirchin Batjargal, Mateusz Rymuszka}}
			
			\vspace{6cm}
			\textbf{{\fontsize{13.5}{12}\selectfont \today}}
		\end{center}  
	\end{titlepage}
	
	{\fontsize{13.5}{12}\selectfont
		\tableofcontents
		\vspace{1cm}
		{\renewcommand{\arraystretch}{2.0}
		\newpage
	}}
	
	\section{Abstrakt}
	
	Przedmiotem projektu realizowanego w ramach przedmiotu Chromatyczna Teoria Grafów przez autorów tego dokumentu jest analiza problemu kolorowania warstwowego grafu. Zespół przygotował, zaimplementował oraz przetestował działanie trzech algorytmów, które będą starały się pokolorować grafy wielowarstwowe w lepszy sposób niż naiwny algorytm duplikacji koloru na wiele warstw. W dokumentacji przedstawiono teoretyczny opis problemu wraz z proponowanymi algorytmami, a następnie sposób działania programu i raport z testów na wybranych rodzajach grafów, podsumowując to wszystko wnioskami płynącymi z obserwacji.
	
	\section{Opis teoretyczny problemu}
	
	\begin{definition}\label{def:1}
		\textbf{Kolorowaniem $p$-warstwowym} grafu $G$ nazywamy takie przyporządkowanie $c: v \rightarrow 2^{C}$, gdzie każdemu wierzchołkowi $v \in V(G)$ przypisujemy podzbiór $C'$ zbioru kolorów $C$ taki, że $|C'| = p$.
	\end{definition}

	\begin{definition}\label{def:2}
		Kolorowanie $p$-warstwowe grafu $G$ nazywamy \textbf{właściwym (poprawnym, optymalnym)}, jeżeli dla dowolnego $v \in V(G)$ przecięcia zbioru kolorów tego wierzchołka i kolorów każdego jego sąsiada są zbiorami pustymi, tzn.
		\[ \forall u, v \in V(G) \quad \left\{u, v\right\} \in E(G) \implies c(u) \cap c(v) = \emptyset \]
	\end{definition}

	Ogólnie rzecz ujmując, kolorowanie wielowarstwowe grafu jest rozszerzeniem zwykłego kolorowania grafu na wiele wymiarów. Kolorowanie jednowarstwowe jest tożsame z klasyczną definicją kolorowania wierzchołkowego grafu.
	
	\begin{definition}
		\textbf{$p$-warstwową liczbą chromatyczną} grafu $G$ nazywamy najmniejsze $q$ takie, że istnieje poprawne $p$-warstwowe pokolorowanie grafu $G$ używające $q$ kolorów.\\
		\textbf{Chromatycznym współczynnikiem $p$-warstwowym} grafu $G$ nazywamy stosunek $p$-warstwowej liczby chromatycznej do liczby warstw.
	\end{definition}

	Okazuje się, że $\chi_{p}G \leq p \chi G$. Gdy weźmiemy bowiem dobre $\chi G$-pokolorowanie $c: V \rightarrow C$ grafu $G$ i dla każdego $v \in V$ przypiszemy mu $c'(v) = \left\{r \cdot |C| + c(v): r \in \left\{1,...,p\right\}\right\}$, to uzyskamy $p \chi G$-pokolorowanie $p$-warstwowe. Nazwijmy je pokolorowaniem $p$-warstwowym grafu $G$ \textbf{równoległym do klasycznego}.
	\\~\\
	Przykładem grafu, który dla którego zachodzi ostra nierówność, jest nieparzysty cykl o wielkości przekraczającej trzy wierzchołki. Takie kolorowanie będziemy nazywać \textbf{lepszym od klasycznego}.
	
	\begin{figure}[H]
		\centering
		\begin{tikzpicture}
			\node[circle, draw, fill=none] (1) [label=south west:{1,2}] at (0,0) {};
			\node[circle, draw, fill=none] (2) [label=south east:{3,4}] at (4,0) {};
			\node[circle, draw, fill=none] (3) [label=south east:{5,1}] at (5,4) {};
			\node[circle, draw, fill=none] (4) [label=north:{2,3}] at (2,6) {};
			\node[circle, draw, fill=none] (5) [label=south west:{4,5}] at (-1,4) {};
			\draw (1) -- (2) -- (3) -- (4) -- (5) -- (1);
		\end{tikzpicture}
		\caption{Przykład 2,5-pokolorowania 2-warstwowego dla grafu $C_{5}$}
	\end{figure}
	
	Problem polega na znalezieniu takiego $p$-warstwowego pokolorowania dla zadanego $p$, aby dla pewnych grafów (takich, gdzie jest to możliwe) $\chi_{p}G < p \chi G$.
	
	\section{Proponowane algorytmy}
	
	Ponieważ problem znalezienia $p$-warstwowego grafu jest NP-trudny (można to wykazać, rozwijając graf warstwowo, gdzie każdy wierzchołek tworzy $p$-krotną klikę, zachowując połączenia z wierzchołkami w każdej z warstw), nie możemy znaleźć takiego pokolorowania w czasie wielomianowym. Zespół skupi się na poszukiwaniu algorytmu aproksymacyjnego, który przy zastosowaniu odpowiedniego podejścia do problemu, a być może pewnych heurystyk, będzie w stanie osiągać rezultat dla niektórych grafów.
	\\~\\
	Wspólnym mianownikiem tych algorytmów powinna być troska, aby starać się kolorować "chaotycznie", tzn. nie powtarzać tych samych zbiorów kolorów w wierzchołkach niezależnych. Taki układ może nas potem zmusić do użycia większej liczby kolorów, a w efekcie uzyskamy pokolorowanie na $p \cdot \chi G$ kolorów.
	
	\subsection{Zmodyfikowany algorytm AMIS}
	
	Algorytm AMIS (\textit{ang. approximately maximum independent set}) jest jednym z efektywniejszych algorytmów wielomianowych kolorowania grafu. W klasycznym problemie, polega on na wyborze spośród niepokolorowanych wierzchołków zbioru niezależnego i pokolorowanie go na nowy kolor. \\~\\
	Algorytm można byłoby zaaplikować bez większych zmian (dopóty wierzchołek uznajemy za niepokolorowany, dopóki nie posiada zbioru $p$ kolorów przypisanych do niego). Istnieje jednak ryzyko, że wybierając te same zbiory niezależne w kolejnych iteracjach algorytmu znajdowania zachłannego zbiorów niezależnych, uzyskalibyśmy pokolorowanie równoległe do klasycznego. Zależy nam zatem, aby w kolejnych iteracjach zbiory niezależne jednocześnie  nie były tożsame oraz nie były rozłączne. \\~\\
	Zaproponowany algorytm będzie korzystał ze zoptymalizowanej wersji algorytmu GIS (\textit{ang. greedy independent sets}), w którym zamiast wyboru wierzchołka na podstawie jego stopnia w grafie indukowanym, będziemy brali również pod uwagę częstość występowania danego wierzchołka w dotychczas wygenerowanych zbiorach niezależnych. 
	
	\subsubsection{Pseudokod}
	
	\begin{algorithmic}
		\State \textbf{Wejście:} graf $G$ i tablica wystąpień w zbiorach niezależnych wierzchołków $f$
		\\
		\Function {GreedyIndependentSet}{$G$, $f$}
			\State $G' \coloneqq G$
			\State $I \coloneqq \varnothing$
			\State less\_rank $\coloneqq true$
			\\
			\While{$V(G') > 0$}
				\State rank $\coloneqq$ [] 
				\ForAll{$v \in V(G')$}
				\State rank[$v$] $\coloneqq f(v) + \deg_{G'}(v)$ 
				\EndFor
				\\
				\If{less\_rank}
					\State $v = maxarg(\text{rank})$
				\Else
					\State $v = minarg(\text{rank})$
				\EndIf
				\State less\_rank $\coloneqq \neg$ less\_rank
				\\
				\State $I \coloneqq I \cup \left\{v\right\}$
				\State $G' = G'[V(G') - \left\{v\right\}- N_{G'}(v)]$
			\EndWhile
			\\
			\State \Return $I$
		\EndFunction
	\end{algorithmic}
	
	\begin{algorithmic}
		\State \textbf{Wejście:} graf $G$, liczba warstw $p$
		\\
		\Function {Color}{$G$, $p$}
			\State colored $\coloneqq 0$
			\State color $\coloneqq 1$
			\State $c \coloneqq \left[\right]$
			\State $f \coloneqq \left[\right]$
			\ForAll{$v \in V(G)$}
				\State $c(v) \coloneqq \varnothing$
				\State $f(v) \coloneqq 0$
			\EndFor
			\\
			\While{colored $< p \cdot |V(G)|$}
				\State $I \coloneqq $ \Call {GreedyIndependentSet}{$G\left[\left\{v \in V(G) : |c(v)| < p \right\}\right]$, $f$}
				\ForAll{$v \in I$}
					\State $c(v) \coloneqq c(v) \cup \left\{ \text{color} \right\}$
					\State $f(v) \coloneqq f(v) + 1$
					\State colored $\coloneqq$ colored $ + 1$
				\EndFor
			\EndWhile
			\State \Return $(\text{color}, c)$
		\EndFunction
	\end{algorithmic}

	\subsection{Zmodyfikowany algorytm DSATUR}
	
	Algorytm DSATUR należy do rodziny algorytmów sekwencyjnych. W klasycznym problemie, polega on na wyborze spośród niepokolorowanych wierzchołków zbioru niezależnego i pokolorowanie go na nowy kolor. Zespół postanowił nieco zmodyfikować ten algorytm i zbadać jego działanie dla problemu kolorowania wielowarstwowego.
	\\~\\
	Saturację w klasycznej wersji tego algorytmu traktowaliśmy jako liczbę unikalnych kolorów w sąsiednich pokolorowanych wierzchołkach. Aby algorytm działał dla wielu warstw, jednocześnie uwzględniając kolory znajdujące się u sąsiadów oraz w wierzchołku, należy zdefiniować nowy porządek. 
	\\~\\
	W celu analizy problemu, możemy rozpatrywać saturację wielorako; zdefiniujmy:
	\begin{itemize}
		\item saturację zewnętrzną, będącą ilością unikalnych kolorów użytych do pokolorowania wierzchołków sąsiednich, tzn.
		\[S^{OUT}_{G}(v) = \left|\bigcup_{u \in N_{G}(v)} c(u)\right|\]
		\item saturację wewnętrzną, będącą ilością kolorów użytych do pokolorowania wierzchołka, tzn.
		\[S^{IN}_{G}(v) = |c(v)|\]
		\item saturację całkowitą, będącą ilością unikalnych kolorów użytych do pokolorowania wierzchołków sąsiednich, tzn.
		\[S_{G}(v) = \left|\left(\bigcup_{u \in N_{G}(v)} c(u) \right) \cup c(v)\right|\]
	\end{itemize}
	Ponieważ $\forall u,v \in V(G) \quad {u, v} \in E(G) \implies c(u) \cap c(v) = \emptyset$ dla poprawnego $p$-warstwowego pokolorowania $c$ grafu $G$, mamy $S_{G}(v) = S^{OUT}_{G}(v) + S^{IN}_{G}(v)$. 
	\\~\\
	Rozpatrzymy dwa przypadki szeregowania wierzchołków na podstawie saturacji:
	\begin{itemize}
		\item wpierw malejąco po saturacji całkowitej, następnie rosnąco po saturacji wewnętrznej
		\item wpierw malejąco po saturacji zewnętrznej, następnie malejąco po saturacji wewnętrznej
	\end{itemize}

	\subsubsection{Pseudokod}

	\begin{algorithmic}
		\State \textbf{Wejście:} graf $G$, liczba warstw $p$, saturacja $S$
		\\
		\State colored $\coloneqq 0$
		\State max\_color $\coloneqq 0$ 
		\\
		\State $s_{in} \coloneqq \left[\right]$
		\State $s_{out} \coloneqq \left[\right]$
		\\
		\Procedure {ColorVertex}{$v$, \&$c$}
			\State color $\coloneqq 1$
			\While{color $\in s(v)$}
				\State color $\coloneqq$ color $+ 1$
			\EndWhile
			\\
			\State $c(v) = c(v) \cup \left\{\text{color}\right\}$
			\State colored $\coloneqq$ colored $ + 1$
			\If{color $>$ max\_color}
				\State max\_color $\coloneqq$ color
			\EndIf
			\\
			\State $s_{in}(v) = s_{in}(v) \cup \left\{\text{color}\right\}$
			\ForAll{$u \in N_{G}(v)$}
				\State $s_{out}(u) = s_{out}(u) \cup \left\{\text{color}\right\}$
			\EndFor
		\EndProcedure
		\newline
		\Function {Color}{$G$, $p$, $S$}
			\State $c \coloneqq \left[\right]$
			\\
			\ForAll{$v \in V(G)$}
				\State $c(v) = \varnothing$
				\State $s_{in}(v) = \varnothing$
				\State $s_{out}(v) = \varnothing$
			\EndFor
			\\
			\State $v \coloneqq rand(\left\{v \in V(G): \forall u \in V(G) \deg_{G} v \geq \deg_{G} u \right\})$
			\State \Call {ColorVertex}{$v$, \&$c$, \&$s$}
			\\
			\While{colored $< p \cdot |V(G)|$}
				\State $v \coloneqq rand(\left\{v \in V(G): \forall u \in V(G) S(v) \geq S(u) \right\})$
				\State \Call {ColorVertex}{$v$, \&$c$, \&$s$}
			\EndWhile
			\\
			\State \Return $(\text{max\_color}, c)$
		\EndFunction
	\end{algorithmic}

	\subsection{Zmodyfikowany algorytm CS}
	
	Ostatnim algorytmem zaproponowanym przez zespół będzie zmodyfikowany algorytm podobny do algorytmu CS (\textit{ang. connected sequential}). Jego modyfikacja będzie polegała na tym, że w przypadku konieczności użycia koloru, zostanie uruchomiona procedura wymiany, bazująca na algorytmie wyznaczania permutacji Fishera-Yatesa. Algorytm zakłada, że w przypadku braku dostępnego koloru z puli, będziemy po kolei iść wzdłuż pewnej ścieżki od naszego wierzchołka i próbować wymieniać kolory do momentu, gdy któryś z wierzchołków będzie się dało pokolorować użytymi już kolorami, albo gdy algorytm zakończy permutację. Nowego koloru użyjemy tylko w drugim przypadku. Aby zwiększyć skuteczność, będziemy sprawdzać wymianę wszystkich możliwych kolorów.
	
	\subsubsection{Pseudokod}
	
	\begin{algorithmic}
		\State \textbf{Wejście:} graf $G$, liczba warstw $p$ \\
		\State colored $\coloneqq 0$
		\State max\_color $\coloneqq 0$
		\\
		\Procedure {ColorInterchange}{$v$, \&$G$, \&$c$}
			\State $A \coloneqq \varnothing$
			\\
			\For{$i \coloneqq 1$; $i \leq V(G)$; ++$i$}
				\State $u \coloneqq rand(\left\{u \in N_{G}(v) - A : c(u) - c[N_{G}(v) \cup \left\{v\right\} - \left\{u\right\}] \neq \varnothing \right\})$
				\State $A \coloneqq A \cup \left\{u\right\}$
				\\
				\ForAll{$x \in c(u) - c[N_{G}(v) \cup \left\{v\right\} - \left\{u\right\}]$}
					\State $c(u) \coloneqq c(u) - \left\{x\right\}$
					\State $c(v) \coloneqq c(v) \cup \left\{x\right\}$
					\\
					\ForAll{$y \in \left\{1, ..., \text{max\_color}\right\}$}
						\If{$y \notin c\left[N_{G}(u) \cup \left\{u\right\}\right]$}
							\State $c(u) \coloneqq c(u) \cup \left\{y\right\}$
							\State \Return $true$
						\EndIf
					\EndFor
					\\
					\State $c(u) \coloneqq c(u) \cup \left\{x\right\}$
					\State $c(v) \coloneqq c(v) - \left\{x\right\}$
				\EndFor
				\\
				\State $x = rand(c(u) - c[N_{G}(v) \cup \left\{v\right\} - \left\{u\right\}])$
				\State $c(u) \coloneqq c(u) - \left\{x\right\}$
				\State $c(v) \coloneqq c(v) \cup \left\{x\right\}$
				\\
				\State $v \coloneqq u$
			\EndFor
			\State \Return $false$
		\EndProcedure
		\\
		\Function {Color}{$G$, $p$}
			\State $c \coloneqq \left[\right]$
			\ForAll{$v \in V(G)$}
				\State $c(v) = \varnothing$
			\EndFor
			\\
			\ForAll{$v \in V(G)$, $l \in \left\{1,...,p\right\}$}
				\ForAll{color $\in \left\{1,...,\text{max\_color}\right\}$}
					\If{color $\notin c\left[\left\{v\right\} \cup N_{G}(v) \right]$}
						\State $c(v) \coloneqq c(v) \cup \left\{\text{color}\right\}$
						\State \textbf{break}
					\EndIf
				\EndFor
				\If{$\neg$\Call {ColorInterchange}{$v$, \&$G$, \&$c$}}
					\State $c(v) \coloneqq c(v) \cup \left\{\text{color} + 1\right\}$
					\State max\_color $\coloneqq$ max\_color $+ 1$
				\EndIf
			\EndFor
			\State \Return $(c, \text{max\_color})$
		\EndFunction
	\end{algorithmic}	
	
	\section{Założenia techniczne}
	
	W wyborze języka, w którym zostanie stworzony program, zespół kierował się przejrzystością implementacji, aby móc skupić się na teoretycznej części problemu. Ostatecznie, program został napisany w języku Python. Jest to język wieloparadygmatowy o wyjątkowo prostej składni, co pozwala w dość obrazowy sposób przedstawić istotę zaproponowanych algorytmów. Dodatkowo, posiada duże wsparcie społeczności oraz bindingi do bibliotek wizualizujących grafy (m.in. Graphviz). 
	\\~\\
	Projekt będzie obejmował:
	\begin{itemize}
		\item interfejs użytkownika (parser wejścia, komunikaty itp.)
		\item implementację wyżej wymienionych algorytmów 
		\item prezentację wyniku (wyjście tekstowe + wizualizacja za pomocą biblioteki Graphviz)
		\item przykładowe benchmarki testujące skuteczność oraz czas wykonania na wybranych grafach
	\end{itemize}

	\section{Zmiany w stosunku do dokumentacji początkowej}
	
	Zespół zdecydował się na zmianę strategii w niektórych algorytmach, ze względu na napotkane trudności implementacyjne:
	\begin{enumerate}
		\item w algorytmie AMIS losowe generowanie wierzchołków i późniejsze usuwanie ich ze zbioru wierzchołków niezależnych, ze względu na brak czynnika wyróżniającego niezbędną kolejność usuwania wierzchołków, może prowadzić do generowania małych zbiorów niezależnych; z tego powodu zdecydowano się wybór jednego wierzchołka, przy zachowaniu parametru częstości występowania w zbiorach niezależnych
		\item do algorytmu DSATUR, poza wyborem wierzchołka na podstawie saturacji całkowitej z preferencją dla wierzchołków o mniejszej saturacji wewnętrznej, dodano wybór wierzchołka na podstawie saturacji zewnętrznej z preferencją dla wierzchołków o większej saturacji wewnętrznej
		\item algorytm Connected Sequential z wymianą wierzchołków będzie starał się przeszukiwać najdłuższą możliwą ścieżkę, aby zwiększyć szansę na wymianę kolorów; dodatkowo, algorytm będzie analizował wszystkich tych sąsiadów, którzy są w stanie wymienić się kolorami (przynajmniej jednym) z aktualnym wierzchołkiem i wybierał losowo spośród nich, a nie wszystkich sąsiadów - ma to uniknąć częstym sytuacjom, gdy wybrany sąsiad nie ma koloru do wymiany
	\end{enumerate}
	
	Ponadto, ostatecznie zespół zdecydował się na implementację algorytmów i testów w języku Python - ze względu na większą prostotę, elastyczność oraz łatwość tworzenia testów i rysowania wykresów obrazujących wyniki eksperymentów.

	\section{Opis struktury projektu}
	
	Projekt będzie składał się z dwóch modułów:
	\begin{itemize}
		\item moduł implementacyjny \texttt{coloring} - zostały w nim zawarte:
			\begin{itemize}
				\item implementacja struktura grafu, oparta o słownik sąsiadów (plik \texttt{graph.py}),
				\item implementacja algorytmów kolorowania warstwowego (plik \texttt{coloring.py}),
				\item moduł generujący przykładowe instancje lub ładujący przykłady z pliku w formie DIMACS (plik \texttt{examples.py})
			\end{itemize}
		\item moduł testów \texttt{test} - zostały w nim zawarte pliki opisujące przeprowadzone testy wydajności i efektywności zaimplementowanych algorytmów
		\item plik \texttt{run.py} - umożliwia uruchomienie jednego lub wszystkich algorytmów na wybranym grafie (w formie pliku DIMACS, podanym jako argument); skrypt zwróci czas potrzebny na wykonanie obliczeń, liczbę kolorów użytych oraz chromatyczny współczynnik otrzymanego pokolorowania, a także wypisze lub zapisze kolorowanie do pliku 
	\end{itemize}

	\pagebreak
	
	\section{Raport z przeprowadzonych testów i eksperymentów}
	
	\subsection{Wprowadzenie}
	
	W trakcie testów zespół starał się ująć istotę problemu w postaci uzyskania chromatycznego współczynnika warstwowego na poziomie niższym niż liczba chromatyczna danego grafu (tzn. uzyskania lepszego pokolorowania niż klasyczne). Z tego powodu dużą rolę w testach pełni odpowiedni dobór grafów wykorzystywanych do testów. 
	\\~\\
	W testach uwzględniliśmy cztery klasy grafów:
	\begin{itemize}
		\item cykle nieparzyste - są to najmniejsze grafy, których warstwowe pokolorowania są lepsze od klasycznych; testy na tych grafach będą służyły jako najprostsze testy skuteczności
		\item grafy Knesera - w szczególności grafy Petersena - ich złożona struktura oraz znana liczba chromatyczna (dla grafu $K(k, n)$ wynosi ona $n - 2k + 2$) pozwolą na przetestowanie skuteczności dla nieco bardziej złożonych grafów niż nieparzyste cykle
		\item grafy losowe, wygenerowane za pomocą modelu Erdosa-Renyi
		\item zbiór grafów trudnych do kolorowania ze strony prowadzącego przedmiot \cite{gci}
	\end{itemize}
	Grafy będą testowane pod kątem skuteczności (tzn. współczynnikowi chromatycznemu dla danej ilości warstw) oraz szybkości algorytmu w porównaniu do innych.
	
	\subsection{Testy na nieparzystych cyklach}
	
	\subsection{Testy na grafach Knesera}
	
	\subsection{Testy na grafach z rodziny DSJC}
	
	% TODO: dodać jeszcze kilka innych sekcji
	
	\section{Wnioski końcowe}
	
	\pagebreak
	
	\begin{thebibliography}{0}
		\bibitem{kubale-article}
		Marek Kubale, \textit{Analiza efektywności algorytmów kolorowania grafów}, PTM 1980\\
		\url{https://wydawnictwa.ptm.org.pl/index.php/matematyka-stosowana/article/viewFile/1531/1457}\\
		\textit{(dostęp: \today)}
		
		\bibitem{kubale-book}
		Marek Kubale, \textit{Optymalizacja dyskretna. Modele i metody kolorownia grafów}, WNT 2002
		
		\bibitem{radin-thesis}
		Andrew Radin, \textit{Graph coloring heuristics from investigation ofsmallest hard to color graphs}, RIT Scholar Works 2000
		\url{http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.867.178\&rep=rep1\&type=pdf}
		\textit{(dostęp: \today)}
		
		\bibitem{gci}
		\url{https://mat.tepper.cmu.edu/COLOR/instances.html#XXCUL}
		\textit{(dostęp: \today)}
		
		
	\end{thebibliography}
	

\end{document}